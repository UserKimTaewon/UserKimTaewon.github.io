# 주요 프로토콜들
- DNS

- SMTP

- POP

- IMAP

- FTP

- HTTP

# 메일 format

유저-에이전트에서 작성한 format, 프로토콜이랑은 조금 다름

작성한 걸 구형?포맷으로 변환.

사실은 내가 쓰는 게 바로 상대한테로 가는 게 아님.

내 이메일 서버에 보내고, 상대방네 이메일 서버랑 통신해서 보내는 거.

보내는 단위가 1줄.


# DNS 프로토콜?

이러한 약속을 지켜서 보내기/해석 ㄱㄴ.

- 매번 quarry:some,reply:some2 대신에

- 걍 순서 정해놓고 some,some2 순으로 보내는 등?



쿼리랑 리플라이랑 같은 포맷 공유..?

쿼리-리플라이?에 id가 있네.

2바이트 id,플래그,#question,...

으로 시작하고..



tcp는 들었는지 확인하고

udp는 들었는지 확인도 없고.

tcp는 그 확인 과정이 좀 복잡..?



# p2p

서버-방식은 중앙 서버가 모든 오버헤드 감당.

p2p는 받은 사람이 새 서?버 처럼 되서 오버헤드 담당.



## bittorrent

얘 기준으론는 중앙에서 적어도 누가 누구한테 주고 받을지는 결정.

파일이 청크 단위로 이동

이기적인(다운만 받고 업로드 없으면)사람 방지?

- 안 이기적이면 다음 다운에 역-혜택

한 그룹끼리만 하면 속도가 떨어지니(locality?)

매 30초마다 새-사람을 그룹에 초대(중앙에서 해줌)

그 뒤 가장 못?해준 친구를 잘라냄.

긍께 자동으로 fit되는 네트웤..인..가..?



# CDNs

vidio.srteaming & cdns?

vid traffic이 인터넷의 주-traffic...

- 망 사용료..?

한 서버가 다-담당하기엔 병목도 그렇고 힘듦..



vid는 용량이 커서 압축 필수(해도 크긴 함)



스트림/다운로드 방식?

- 스트림은 다운 받으면서 플레이

- 다운로드는 다운 다 받고 플레이.

- 유사 컴파일 vs 인터프리터



# DASH?

- Dynamic Adaptive Streaming over HTTP

- http 기반 개량..?

- 기존의 http는 파일을 항상 한조각.

- 여기선 파일을 청크 단위로 나눔(안그럼 넘 큼)

- 청크-단위로 인코딩..?

- 청크에 대해 여러 압축 방식을 동시에 사용

- menefest file:다른 여러 청크(압축 방식 등?)에 대한 URL 결정

클라이언트에서 가용 네트웤-대욕폭 보고

언제 req 할지,

어떤 압축률을 고를 지,

어디에 req 할지

를 클라가 결정해야.



# CDN=Contenet Distrivution Netrork

한 대형-서버로 하면

병목이 생김(먼 데에선 더 오래 걸림..)

대신 여러 군데에..

- 지역별 대형 데타-센터?

- 작은 소형-서버 여러곳에?

## 지역별 대형 데타-센터?

Akamai가 이런 서비스 제공.

전세계 1700개...

국을,넷플릭스 정도 크기 아니면 이런 데에 맏기는게..

아무튼 이런 식으로 컨텐트를 여러 서버에 복사본을 나눠놓는 방식=CDN



cdn에 유저가 요청을 하면

가장 가깝고 빠른 서버에 요청하게 해줌.

(with menefest file)

하다 중간에 혼잡이 생기면 새 경로 고를수도



## "over the top"?

=OTT?

예전엔 셋톱을 통해 받음

이젠 법용-기기+인터넷으로 받음.

그게 OTT.



셋톱(등의 필수 주번기기)을 넘어섯다는 뜻



인터넷-혼잡의 주 원인..



# UDP

소켓 프로그래밍..?

- 어플리케이션에서 네트웤과 통신하는 방식. 최?상?위?API?

소켓 관련 라이브러리?API?

는 항상 OS와의 연결로 돌아감.



파이썬 기준으로

`from sorket import *`하고



`socket(AF_INET,SOCK_DGRAM)`

으로 소켓 생성.



`AF_INET`-ipv4 쓴다

`SOCK_DGRAM`-udp 쓴다



`socket.sendto(body:byte[],to:Tuple[server_name,server_port])`

로 보내기.

`socket.recvfrom(n_bytes)`

로 받을 수도.

`bytes`로 받는 것 같으니

`.decode`로 `str`로 변환 ㄱㄴ.



서버에서는

`socket.bind((name,port))`

로 port에 bind 해야.

`messege,adress=sorket.recvfrom(bytes)`

로 bytes를 보냄.
