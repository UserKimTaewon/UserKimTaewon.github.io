# 기말

6/17 금

1:30~3:00

507호(지난번과 동일)





# 과제

SQL 실습

배점 마니 줌..?

ref 오세강 교수님 식습 자료..?



거기 다 있으니 따로 안적어도 될듯.



데이터는 임의적-으로 넣..어야..??



뭐지;;



다는 말고

저기 있는 실습 과제중 과제별 3~4개정도 '선택해서'하기.

문제 직접 만들어도 됨;;

table 최소 2개는 써보기..?

- join..?



계산?sort?집합 연산?

등 해보기?



limit 3이나 top 3 등으로 limit 가능한 경우가..?

DBMS에는 내장-비표준 함수들이 좀 있음.

LOWER,DATE 등...



## 즉,과제가

실습과제 1,2,3 문제 일고

데이터 임의로 입력하고



과제별로 4+분제 추출해서 실행.



자기 홈피에 입력 내용,결과 보여줘야.

6.23까지...?

- 오. due 널널하네

# 회복과 병행제어

사용자에서 의식 안해도 해주는 기능?

>오세강-교수님 강의자료서 빌려온 거?



## todo=

트랜잭션.

트랜잭션?

- 쿼리들 묶은 하나의 단위.

- 정상적으로 실행 되면 아무 문제 없지만..

- 문제가 생기면 어케?

- 거기에 여러 트랜잭션이 동시에 끼어들거나 하면..?

	- 동시 접근에도 문제 없이 작동해야...



## 트랜잭션.개념

"DB 상태를 변경시키기 위해 수행하는 작업단위"

작업을 수행하기 위해 필요한 DB.연산을 모아놓은 것..?



INSERT/DELETE/UPDATE가 주.

>SELECT는 변경이 없어서.



특히 이것들이 중간에 문제 생기면 어케..?

- 보통은 rollback이 기본..?

- 그래서 commit 전까지는 트랜잭션 전의 data를 저장해둠.



병행 작업시?

- 둘이 동시에 바꾸는 경우 문제가 생기기도...



무결셩,일관성을 위해..?

## 트랜잭션.예시

항공기 예약,신용카드 처리,등...

보통 수천/수백명의 사용자들의 동시 접근 처리해야.

많은 사용자들이 DB의 서로 다른/동일한 부분을 접근..



동시성 제어

- 같이 써서 문제 안생기게.

- 즉, 순서대로 쓴거랑 결과가 같게.



### ex

5000원을 이체한다면



UPDATE 계좌

SET 잔액=잔액-5000

WHERE 계좌번호 = 100

UPDATE 계좌

SET 잔액=잔액+5000

WHERE 계좌번호=200



근데 이게 중간에 문제 생기면

돈이 증발하거나,생성되거나...



## 트랜잭션.특성

=ACID

=원자성,일관성,격리성,지속성



### 원자성

=Atomicity

한 트랜잭션의 연산들이 '모두 정상적으로 실행'되거나

'하나도 실행이 안되야' 함.

=All-or-nothing 방식?



그러니까 도중에 문제가 생기면

지금까지 한 연산을 모두 취소하고

트랜잭션 전 상태로 돌려야..



이걸 위해 회복 기능이 필요?

### 일관성

=consistancy

성공적으로 수행된 후에도 데이터베이스가 '일관된'상태르 유지해야 함을 의미.



여러 의미가 있음

크게 말하자면 '말이 되야'.

ex:

필드 타입이 바뀌면 안됨

돈이 생성/증발되면 안됨.

등...



사실 중간에는 일관성 불일치여도 되지만

시작/끝에서만 지켜지면 됨.

### 격리성

=독립성=고립성

=isolation

수행중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산 결과에 접근할 수 없는 거.



- 사실 완전히 막으면 성능이..

- 그래서 결과만 같게



이걸 위해

여러 트랜잭션이 동시에 수행되도

마치 순서대로 하나씩 수행되는 것처럼

정확하고 일관된 결과 나오게 제어하는 기능 필요.



가장 쉬운 방법은 저거 정의대로지만

그러긴 성능이 영..

### 지속성

=durability

성공적으로 완료된 후

DB에 반영한 수행 결과는 영구적이여야.



이걸 위해 장애시 회복 기능이 필요?



### 이걸 위해 필요한 기능

원자성,지속성:회복 기능

일관성,격리성:병행 제어 기능.



## 트랜잭션.주요 연산

commit

- 성공적으로 수행됨을 선언.

rollback

- 실패했음을 선언.



### commit

이게 실행되면 수행 결과가 영구적으로 반영되고

일관성이 유지됨.



### rollback

에러시.

수행 실패했음을 선언.

이거 실행하기 직전에는 dB가 불일치 상태일 수도...



수행하던 갱신은 다 되돌려짐.



둘 다 보통 DBMS가 알아서 함.



## 트랜잭션.상태

``` 

트랜잭션 수행->활동->부분 완료->실패->철회

활동->실패

부분 완료->완료

```

## 오류 vs 결함 vs 장애

오류:

부정확한 결과를 초래하는 인간의 실수.

- 인간이 원인.

결함:

필요한 기능을 수행 못하게 하는 컴포넌트/시스템 상의 결점.

오류 땜시 생김.

@사족

## fault-tolerant

결함이 있더라도 극복 가능한 능력.

=결함-허옹.



하드/소프트 적 여러 방법이 있음.



여러 곳에서 사용되는 거.

하드웨어적

- 같은 작업을 여러 물리적-다른 컴터에 시킴..?

	- 원자력 발전소 수준이면 진짜 이방법 씀

	- 완전-크리티컬+그만큼 방사선 오류도 있고

- 한 컴터에서 3+개의 모듈에서 같은 연산을 수행.

소프트적

- 결함시 rollback

- rollback+다른 곳에서

- 여러 솦트적-모듈

데이터 통신

- 체크섬

- 패리티-비트

- 해밍 코드

## 장애와 회복

### 장애

트랜잭션 장애

- 트랜잭선 수행 중 오류.

- 논리적 오류/OOM/NullPointer/...

시스템 장애

- 하드웨어적 문제로 

- 교착 상태 등

미디어 장애

- 저장 장치가 문제나서 DB의 일부/전체가 손상.



이거 말고도 통신/물리적/... 등 여럿 있음.



#### 저장 장치

휘발성

- 장애시 저장된 데이터 날라감

비휘발성

- 장애 나도 손실..이 잘 안되지만

- 헤더 손상 등으로 자체 이상이 생기면 날아감.

안정

- 비휘발성 여러개로 사본 여러개 만들기.

- 장애 나도 데-타 손실 안나고 영구적으로 저장 ㄱㄴ..?

트랜잭선의 수행을 위해 필요한 데이터-이동 연산?

- 디스크<->메인 메모리는 input/output

- 메인 메모리<->프로그램 변수는 r/w

\\<-- !졸기 시작 -->
!졸기 시작



디스크<->메인 메모리 연산의 필요성?

- 일반적으로 DB는 비휘발성 장비인 디스크에 상주.

- 트랜잭션 처리를 위해서는보통 디스크->메인 메모리로 처리하고

- 그 겨ㄹ과를 w해야.







@사족

'프로그램 내장 방식'?

- by 폰 노이만



보통 메모리는 블록-단위로 왔다 갔다 ㅏㅎㅁ.



#### 회복

by DBMS 내장 ghlqnr hksflwks.



dump?

- 돌아갈 곳 저장.?



dump/log

- dump는 full-사상태 저장.

log는 변경 내역..?

- 둘의 비용 생각헤ㅐ서 적적ㄹ



redo

undo

- 말 그대로 모든 ㅣㅐㅎfmf durdmfhgo



\\<-- !쉬는 시간 -->
!쉬는 시간



로그 파일

- 데이터 변경 전/후의 값 기록한 파일.



레코드 단위로 트랜잭선 수행과함께 기록횜



시작/변경/끝

로드 레코드.유형이?



<T1,start>

<T1,$vname,$prev,$after>

<T1,commit>



##### DB.회복 기법

###### 로그 회복 기법

즉시 갱신 회복 기법

- 매 변경을 log 파일에.

- 로그 파일에 먼저 쓰고 그 뒤에 변경.

- 장애 발생 시점에 따라 re/undo를.

	- start는 있는데 끝에 commit이 없는 트랜잭션은 다 undo

	- 둘 다 있으면 redo

		- 재실행!



지연 갱신  ""

- 변경을 아예 DB에는 적용 안하고,

- 로그 파일에만 넣음.

- 그리고 완료된 후에 그제서야 DB에 적용.

- 이 경우에는 undo 할 필요 없이 걍 무시하면 됨.

검사 시간 ""

- 로그 기능을 쓰긴 하는데

- 일정 간격으로 검사 시점마다 checkpoint를 만듦.

- 검사 시점이 되면

	- 모든 로그 레코드릴 기록,

	- 변경 내역을 안전한 곳에 기록

	- 검사 시점을 log에 남김.

- 장애시 가장 최근 검사 시점 이후의 것에 대해서만.

- 로그 전체를 대상으로 회복하긴 너무 비싼?경우...



미디어 ""

- 디스크 장애 대처용.

- dump=복사본 이용

	- 일정 주기마다 다른 안전한 곳에 전체-저장

- 디스크 발생시 가장-최근의 dump로 장애 전 복구

 +필요에 따라 redo











### 병행 제어

병행 수행과 병행 제어?

병행 수행=concurrency

- 여러 트랜잭션이 동시에 수행되는 거.

- 여러 트랜잭션이 차례로-번갈아 수행되는 인터리빙 방식...?

- 문제 안생기ㅔㄱ 제어 해야..?





#### 동시성 제어

거의 모든 DBMS는 다수 사용자용

여러 사용자가 동시에-동일한 table 접근하는 경우 많음...



##### 병행 수행시 potential problem?

갱신 분실

- 한 트랜잭션의 결과를

 다른 트랜잭선이 덮어쓰는 것.

- 이론상 걍 순차적으로 하면 문제가 없긴 한데...

모순성=inconsistency

- 여러 트랜잭션이 동시에 수행할 때

- 잠깐 일관성 없는 상태의 DB에서 가져와서 문제 생기는 경우.

연쇠 복귀=cascading rollback

- 트랜잭션 하나가 rollback이면

- 걔 결과를 가져온 다른 트랜잭션들도 다 rollback 해야...

- 여러 트랜잭젼이 동시에 수행되더라도 이 문제 안나고 순차적으로 수행한 거랑 같은 결과를 얻을 수 있어야..?



#### 트랜잭션 스케쥴

트랜잭션네 연산을 수행하느 순서



1.직렬 수케쥴

- 무식하게 걍 sequeltial

- 간단하지만 성능이..

2.비직렬 스케쥴

- 인터리빙을 사용만 하는 거.

- 안전은 안함..

3.직렬 가능 스케쥴

- 직렬과 결과가 같은 비직렬 스케쥴.



##### 직렬 가능 스케쥴

=비직렬로 수행해도 직렬과 같은 결과가 나는 비직렬 스케쥴



이거 판단은 꽤 복잡함. DBMS가 해야..



##### 병행 제어 기법?

=병행 수행하면서 직렬 가능성 보장하기 위한 기법

방법?

- 모든 트랜잭션이 준수하면 직렬-가능성이 보장되는 규약 정의.

- 모든 트랜잭션이 그거 따르게.

대표적인게 locking 기법.



###### locking

한 트랜잭션이 먼저 접근한 데이터에 대한

연산을 끝낼 때 까지는

다른 트랜잭션이 그 데이터에 접근 못하게

상호 배제-mutual exclusion



lock,unlock 연산으로.

lock:독점권 요구

unlock:독점권 반납.



한번 lock된 데이터는 다른 데에서는 unlock 전까진 lock  불가능.



공용/전용 락?

공용 락

- lock되도 read는 문제 없음

- w는 아무도 안되지. (주인도.)

- 그리고 여럿이 공용 락을 가질 수 있음

전용 락

- lock되면 주인 말고는 read도 안됨.

- 주인은 r/w 다 ㄱㄴ.

- 단 한명의 주인이 존재 ㄱㄴ.



그래서 보통 읽기만 할 때는 공용 락 요청.



unlock을 너무 일찍 해도 문제가...



####### 2PLP=2단계 locking 규약

기본 규약의 문제를 해결하고,직렬 가능성 보장을 위해

lock/unlock의 수행 시점에 새로운 규약을 추가한 것..?



방법:

축소/확장 단계가 있어서

확장동안은 lock만,

축소동안은 unlock만 가능.

그리고 시작->확장->축소->끝

순서만 가능.

트랜잭션 시작하면 확장단게로 가고,

대충 다 쓴 것 같으면 그때부터 축소단계.



>물론 lock을 한번에 다 할 필요는 없음.

>lock 시점은 최대한 미뤄도 괜찮음.

>규약만 지킨다면.



####### 교착 상태=deadlock

트랜잭선들이 상대가 독점하고 있는 데이터에 unlock연산이 실행되기르 서로 기다리며 수행을 중단하고 있는 상태.



운영체제 거기 가서나 해결 법 배움.





####### 로킹 단위

lock 연산을 거는 대상 데이터의 크기.

- 전체 DB~릴레이션/튜블/속성까지...

- 더 작은 범위 갈수록 관리가 복잡해짐.

	- 대신 병행성 증가

- 더 큰 범위 갈수록 관리는 쉽지만 병행성 감소



######## 다중 로크 단위?

...

ref ppt

보통 DBMS는 각 트랜잭션네 접근하는 튜플 수에 따라..









### 회복

트랜잭션 t 수행 중에 down됬을 때

t의 일부분암 디스크에 반영되면..?

- 어케 취소?

아니면 t 수행은 끝났는데 disk에 안적히면...?



보통 트랜잭션은 버퍼에, 버퍼에서 디스크 순임.

- 속도를 위해.

그래서 버퍼->디스크는 최대한 줄이는 게 보통임.



방법?

- redo/undo 2개.

- commit 전인 거는 undo,

- commit 한거는 redo



고장?

- 재해적/비재해적 2종.

- 재해적은 외부-백업 써야.

- 비재해적은 로그갖고 복구 ㄱㄴ.

